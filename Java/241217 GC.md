# Garbage Collection(GC)
- JVM의 힙 영역에서 필요 없는 객체를 주기적으로 자동으로 정리하는 기능.
- 장점 : 자동으로 처리해줘서 개발자가 신경쓸 일이 없다는 것
- 단점 : 언제 처리하는지 정확하게 알수 없어서 제어가 힘들고, GC가 동작할 때는 다른 동작이 멈추기 때문에 오버헤드가 발생할 수 있음. 빈번한 GC는 성능에 문제가 생김.

### **Stop-The-World**
- GC를 수행하기 위해 모든 애플리케이션 스레드가 일시적으로 중단되는 현상
- 메모리 정리와 메모리 일관성을 위해서 이런 현상이 발생됨. (완전히 없앨수 없음)
- 방지 방법
    1. 힙 사이즈 조절 → 컬랙션 빈도 줄이기
    2. 객체 생성 최소화 및 재사용
    3. 스레드 풀 사용 : 스레드 생성 소멸에 따른 오버헤드 줄여서 GC 부하 줄임

## GC 의 종류
### 시리얼 GC (Serial GC)
- 가장 최초의 가비지 컬렉터
- 단일 스레드로 동작하는 가장 단순한 형태
- 작은 힙 메모리와 단일 스레드에 적합
- Stop-The-world 시간이 가장 길게 발생
- Mark-Sweep, Mark-Compact 알고리즘 사용.

### 패럴럴 GC (Parallel GC)
- Java 5부터 8까지 default 가비지 컬렉터로 사용
- Young영역의 GC를 멀티스레드로 수행 (높은 처리량 초점)
- Old 영역에서는 여전히 시리얼 방식으로 수행되어 성능 저하가 발생할 수 있음.
- Mark-Sweep, Mark-Compact 알고리즘 사용.(Young 영역은 병렬 처리)

### 패럴럴 올드 GC (Parallel Old GC)
- Parallel GC의 확장된 버전
- Young영역 뿐만 아니라 Old 영역에서도 멀티 스레드를 활용하여 수행

### CMS GC (Concurrent Mark Sweep GC)
- ava 5부터 8까지 사용된 가비지 컬렉터
- 애플리케이션 실행 중에 가비지 컬렉션을 수행하여 Stop-The-world 시간을 최소화 하도록 설계
- 메모리와 CPU 사용량이 많고, 메모리 압축을 수행하지 않아 메모리 단편화 문제가 발생.
    - 메모리 파편화?
        - 사용 가능한 메모리가 작은 조각들로 나뉘어져 큰 연속된 메모리 블록을 할당하기 어려운 상태를 의미
        - 왜 발생함? → 가비지 컬렉션 후에 살아있는 객체들을 재배치하여 메모리 공간을 정리하지 않지 않아 발생. (Compact 과정)
- Mark-Sweep, Concurrent Mark Sweep (동시에 GC 수행) 알고리즘 사용
- Java 9부터 deprecated 되고, Java 14에서 완전히 제거

#### (+) CMS GC는 deprecated 되었지만 특정 환경에서는 적절하게 동작한다.
기존 Java 8 기반의 카산드라 배포에서는 CMS GC가 자주 사용 → CMS GC는 오랜 기간 동안 Cassandra에서 사용되면서 성능 특성과 한계가 잘 알려져 있다보니 일부 운영 환경에서는 CMS GC의 **예측 가능한 동작**을 선호할 수 있고 **읽기/쓰기 작업의 비율**이 높거나 JVM 힙 크기가 중간 크기(수 GB)에 머무는 카산드라 환경에서는 CMS GC가 적절히 동작.
- 아파치 카산드라 : **아파치 카산드라**(Apache Cassandra)는 자유-오픈 소스 분산형 NoSQL 데이터베이스 관리 시스템
  

### G1 GC (Garbage First GC)
- Java 9부터 default 가비지 컬렉터
- 힙을 작은 영역으로 나누어 각 영역에 대해 독립적으로 가비지 컬렉션을 수행하는 방식으로, 예측 가능한 지연 시간을 제공.
- 메모리 파편화 문제를 해결하고, 짧은 지연 시간과 높은 처리량을 제공.
- 매우 큰 힙크기에서는 최적화되어있지만 오히려 작은 힙에서는 메모리 관리 오버헤드로 인해 다른 GC보다 성능이 떨어질 수 있음.
- 복잡한 알고리즘으로 인해 설정이 어려울 수 있음.
- Region 기반의 복합적인 알고리즘 (Young 영역, Old 영역을 작은 Region으로 나누어 관리)

### Z GC
- Java 11부터 도입된 가비지 컬렉터
- 저지연 Stop-The-World와 대용량 힙 처리를 목표
  
### Shenandoah GC (셰넌도어)
- Red Hat에서 개발한 가비지 컬렉터
- Java 12부터 도입
- G1 GC와 마찬가지로 힙을 여러 개의 region으로 나누어 처리
- ZGC처럼 저지연 Stop-The-World와 대용량 힙 처리를 목표
- 아직 상대적으로 새로운 기술이므로 충분히 검증되지 않았으며, 일부 환경에서는 성능이 예상보다 낮을 수 있음.


<br>

----

<br>

## GC 알고리즘

### 1. Mark-and-Sweep 알고리즘
- **원리:** 루트 객체(스택 프레임, 정적 변수 등)에서 시작하여 참조 가능한 모든 객체에 표시(mark)함. 표시되지 않은 객체는 더 이상 참조되지 않는 객체이므로 가비지로 판단하여 회수(sweep).
- **장점:** 구현이 간단하고, 다양한 언어에서 사용
- **단점:** 메모리 단편화 문제가 발생할 수 있음.

### 2. Copy 알고리즘
- **원리:** 메모리를 두 개의 영역으로 나누고, 한 영역에서 다른 영역으로 살아있는 객체만 복사. 사용되지 않는 영역은 모두 비워지므로 메모리 단편화 문제가 발생하지 않음.
- **장점:** 메모리 단편화가 없고, 메모리 회수 속도가 빠름.
- **단점:** 전체 메모리의 절반만 사용할 수 있음

### 3. Mark-Compact 알고리즘
- **원리:** Mark-Sweep 알고리즘과 비슷하게 객체를 순회하여 살아있는 객체에 표시를 한 후, 살아있는 객체를 메모리의 한쪽으로 이동시켜 연속된 공간을 만듦.
- **장점:** Mark-Sweep 알고리즘의 단점인 메모리 단편화 문제를 해결하고, Copy 알고리즘보다 메모리 공간 활용도가 높음
- **단점:** 객체 이동 과정에서 오버헤드가 발생할 수 있음.

### 4. Generational GC
- **원리:** 객체의 생존 시간에 따라 Young 영역과 Old 영역으로 나누어 관리. Young 영역에서는 대부분의 객체가 빠르게 소멸되므로 Copy 알고리즘을 사용하고, Old 영역에서는 Mark-Compact 알고리즘을 사용함.
- **장점:** 대부분의 객체가 Young 영역에서 소멸되므로 GC 시간을 단축할 수 있음.
- **단점:** 영역을 나누어 관리해야 하므로 복잡성이 증가.