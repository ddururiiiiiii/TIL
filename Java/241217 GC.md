# Garbage Collection(GC)
- JVM의 힙 영역에서 필요 없는 객체를 주기적으로 자동으로 정리하는 기능.
- 장점 : 자동으로 처리해줘서 개발자가 신경쓸 일이 없다는 것
- 단점 : 언제 처리하는지 정확하게 알수 없어서 제어가 힘들고, GC가 동작할 때는 다른 동작이 멈추기 때문에 오버헤드가 발생할 수 있음. 빈번한 GC는 성능에 문제가 생김.

### **Stop-The-World**
- GC를 수행하기 위해 모든 애플리케이션 스레드가 일시적으로 중단되는 현상
- 메모리 정리와 메모리 일관성을 위해서 이런 현상이 발생됨. (완전히 없앨수 없음)
- 방지 방법
    1. 힙 사이즈 조절 → 컬랙션 빈도 줄이기
    2. 객체 생성 최소화 및 재사용
    3. 스레드 풀 사용 : 스레드 생성 소멸에 따른 오버헤드 줄여서 GC 부하 줄임

## GC 의 종류
### 시리얼 GC (Serial GC)

- **특징:** 가장 단순한 GC 알고리즘으로, 하나의 스레드에서 순차적으로 가비지 컬렉션을 수행.
- **장점:** 구현이 간단하고, 메모리 오버헤드가 적다.
- **단점:** 성능이 낮고, 큰 힙에 적합하지 않음. (주로 단일 CPU 환경이나 작은 힙에서 사용)
- Mark-Sweep, Mark-Compact 알고리즘 사용.

### 패럴럴 GC (Parallel GC)
- **특징:** 여러 개의 CPU 코어를 활용하여 Young Generation에서의 가비지 컬렉션을 병렬적으로 수행.
- **장점:** Young Generation에서의 가비지 컬렉션 속도를 크게 향상시킬 수 있음.
- **단점:** Old Generation에서는 여전히 시리얼 방식으로 수행되어 성능 저하가 발생할 수 있음.
- Mark-Sweep, Mark-Compact 알고리즘 사용.(Young 영역은 병렬 처리)

### 패럴럴 올드 GC (Parallel Old GC)
- **특징:** Parallel GC의 확장된 버전으로, Young Generation뿐만 아니라 Old Generation에서도 병렬 처리를 지원.
- **장점:** 전체적인 가비지 컬렉션 성능을 향상시킬 수 있음.
- **단점:** Parallel GC와 동일한 단점을 가지며, 짧은 지연 시간이 요구되는 애플리케이션에는 적합하지 않을 수 있음.

### CMS GC (Concurrent Mark Sweep GC)
- **특징:** 애플리케이션 실행 중에 가비지 컬렉션을 수행하여 응답성을 높이는 것이 목표.
- **장점:** 짧은 지연 시간을 제공하며, 대규모 힙에서 효과적.
- **단점:** 메모리 파편화 문제가 발생할 수 있으며, Full GC 시 성능 저하가 발생할 수 있음.
    - 메모리 파편화?
        - 사용 가능한 메모리가 작은 조각들로 나뉘어져 큰 연속된 메모리 블록을 할당하기 어려운 상태를 의미
        - 왜 발생함? → 가비지 컬렉션 후에 살아있는 객체들을 재배치하여 메모리 공간을 정리하지 않지 않아 발생. (Compact 과정)
- Mark-Sweep, Concurrent Mark Sweep (동시에 GC 수행) 알고리즘 사용.

### G1 GC (Garbage First GC)
- **특징:** 힙을 작은 영역으로 나누어 각 영역에 대해 독립적으로 가비지 컬렉션을 수행하는 방식으로, 예측 가능한 지연 시간을 제공.
- **장점:** 메모리 파편화 문제를 해결하고, 짧은 지연 시간과 높은 처리량을 제공.
- **단점**
    - 매우 큰 힙크기에서는 최적화되어있지만 오히려 작은 힙에서는 메모리 관리 오버헤드로 인해 다른 GC보다 성능이 떨어질 수 있음.
    - 복잡한 알고리즘으로 인해 설정이 어려울 수 있음.
- Region 기반의 복합적인 알고리즘 (Young 영역, Old 영역을 작은 Region으로 나누어 관리)
- Java9부터 기본 GC.

### Shenandoah GC (셰넌도어)
- **특징:** 저지연, 고성능을 목표로 설계된 최신 가비지 컬렉터. Unique Region Copying 알고리즘을 사용하여 메모리 복사 시 Stop-the-World 시간을 최소화.
- **장점:** 매우 짧은 지연 시간과 높은 처리량을 제공.
- **단점:** 아직 상대적으로 새로운 기술이므로 충분히 검증되지 않았으며, 일부 환경에서는 성능이 예상보다 낮을 수 있음.

### Z GC
- **특징:** Shenandoah GC와 유사하게 저지연, 고성능을 목표로 설계되었으며, 더욱 향상된 성능을 제공.
- **장점:** 짧은 지연 시간, 높은 처리량, 그리고 낮은 메모리 오버헤드를 제공.
- **단점**
    - 매우 큰 힙크기에서는 최적화되어있지만 오히려 작은 힙에서는 메모리 관리 오버헤드로 인해 다른 GC보다 성능이 떨어질 수 있음.
    - ZGC는 초기에는 Linux와 macOS에서만 지원되었으며, 현재는 Windows도 지원하지만 여전히 일부 특화된 환경에서는 사용할 수 없음.
    - ZGC는 지연 시간을 줄이는 데 특화되어 있지만, 매우 높은 처리량을 요구하는 애플리케이션에서는 다른 GC(예: Parallel GC)보다 효율성이 떨어질 수 있음.
    - ZGC는 쓰레드 간 동시성을 높이기 위해 더 많은 CPU 리소스를 소비할수 있음. CPU 리소스가 제한적인 환경에서는 성능 저하를 초래할 수 있음.
- Java11부터 도입, 15부터는 안정적적인 기능으로 전환하여 실사용 가능 (여전히 특정 사용사례(낮은 지연시간과 대규모 힙)에서만 권장되는 중)

#### (+) CMS deprecated 관련
기존 Java 8 기반의 카산드라 배포에서는 CMS GC가 자주 사용 → CMS GC는 오랜 기간 동안 Cassandra에서 사용되면서 성능 특성과 한계가 잘 알려져 있다보니 일부 운영 환경에서는 CMS GC의 **예측 가능한 동작**을 선호할 수 있고 **읽기/쓰기 작업의 비율**이 높거나 JVM 힙 크기가 중간 크기(수 GB)에 머무는 카산드라 환경에서는 CMS GC가 적절히 동작.
- 아파치 카산드라 : **아파치 카산드라**(Apache Cassandra)는 자유-오픈 소스 분산형 NoSQL 데이터베이스 관리 시스템


<br>

----

<br>

## GC 알고리즘

### 1. Mark-and-Sweep 알고리즘
- **원리:** 루트 객체(스택 프레임, 정적 변수 등)에서 시작하여 참조 가능한 모든 객체에 표시(mark)함. 표시되지 않은 객체는 더 이상 참조되지 않는 객체이므로 가비지로 판단하여 회수(sweep).
- **장점:** 구현이 간단하고, 다양한 언어에서 사용
- **단점:** 메모리 단편화 문제가 발생할 수 있음.

### 2. Copy 알고리즘
- **원리:** 메모리를 두 개의 영역으로 나누고, 한 영역에서 다른 영역으로 살아있는 객체만 복사. 사용되지 않는 영역은 모두 비워지므로 메모리 단편화 문제가 발생하지 않음.
- **장점:** 메모리 단편화가 없고, 메모리 회수 속도가 빠름.
- **단점:** 전체 메모리의 절반만 사용할 수 있음

### 3. Mark-Compact 알고리즘
- **원리:** Mark-Sweep 알고리즘과 비슷하게 객체를 순회하여 살아있는 객체에 표시를 한 후, 살아있는 객체를 메모리의 한쪽으로 이동시켜 연속된 공간을 만듦.
- **장점:** Mark-Sweep 알고리즘의 단점인 메모리 단편화 문제를 해결하고, Copy 알고리즘보다 메모리 공간 활용도가 높음
- **단점:** 객체 이동 과정에서 오버헤드가 발생할 수 있음.

### 4. Generational GC
- **원리:** 객체의 생존 시간에 따라 Young 영역과 Old 영역으로 나누어 관리. Young 영역에서는 대부분의 객체가 빠르게 소멸되므로 Copy 알고리즘을 사용하고, Old 영역에서는 Mark-Compact 알고리즘을 사용함.
- **장점:** 대부분의 객체가 Young 영역에서 소멸되므로 GC 시간을 단축할 수 있음.
- **단점:** 영역을 나누어 관리해야 하므로 복잡성이 증가.