# JVM (Java Virtual Machine)
- JVM이 어떤 것인지, 어떤 구조를 가지고 있는지 무슨 일을 하는지에 대한 정리



## 자바 애플리케이션 구동 원리
- 먼저 JVM이 무엇인지 알아보기 전에 소스코드가 어떤 형태로 동작하는지 알아봐야 함!
1. 개발자가 소스코드를 작성함 (.java 형태로 저장)
2. 컴퓨터가 알아들을 수 있는 언어로 변환하는 컴파일러가 컴파일함. (java에서는 Javac가 이 역할을 함)
3. 컴파일러가 컴파일하여 바이트 코드(컴퓨터가 알아들을 수 있는 언어로 변환하는 과정의 중간 언어) 생성 (.class 형태)
4. 이 바이트 코드를 JVM을 통해 컴퓨터가 알아들을 수 있는 언어로 변환하여 운영체제로 전달

---

<br>

## JVM

- 자바 프로그램이 실행되는 가상의 컴퓨터
- 플랫폼의 독립성을 가짐.
    - 플랫폼의 독립성? Windows, MacOS, Linux 같은 서로 다른 운영체제에서도 같은 자바 코드가 돌아갈수 있게 해줌.


## JVM 구조
- JVM은 크게 클래스 로더, 런타임 데이터 영역(JVM메모리 영역), 실행엔진으로 나뉜다.
- 동작 방식
  1. 클래스 로더를 통해 바이트 코드를 불러옴
  2. 클래스 로더가 런타임 데이터 영역에 필요한 클래스를 올림
  3. 런타임 데이터 영역에 올라온 바이트 코드는 실행엔진을 통해 해석됨

## 클래스 로더
- 로드 - 링크 - 초기화 순으로 작동
1. 로드 : 클래스 파일을 메모리에 로드
2. 링크 : 클래스 파일을 검증함
3. 초기화 : 클래스 변수들을 적절한 값으로 초기화함

----

## 실행 엔진 (Execution Engine)
- 바이트 코드를 읽어서 실행하는 곳.
- 크게 인터프리터, JIT컴파일러, 가비지 콜렉터로 나뉨.

### 인터프리터
- 바이트 코드 명령어를 하나씩 해석하고 실행
- JVM 안에서 바이트 코드는 기본적으로 인터프리터 방식으로 동작 (전체적인 속도 느림)

### JIT 컴파일러
- 인터프리터의 단점을 보안하기 위한 방식
- 바이트 코드 전체를 컴파일해서 네이티브 코드로 변경하고 캐싱해 두었다가 네이티브 코드로 직접 실행함.
- 모든 바이트 코드를 네이티브 코드로 변환하면 비용이 소모 되기 때문에 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일 방식으로 실행하는 방식으로 진행.
- 네이티브 코드? → 자바의 부모가 되는 언어인 C, C++, 어셈블리어로 구성된 코드.

### 가비지 콜렉터
- 힙 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 정리해줌.


----

## 런타임 데이터 영역
- JVM의 메모리 영역
- 즉, 자바 애플리케이션을 실행할 때 사용되는 데이터를 적재
- 메소드, 힙 영역은 모든 스레드가 공유 / 나머지 영역은 스레드마다 생성됨.
- 메소드영역, 힙영역, 스택영역, PC레지스터, 네이티브 메소드 스택 영역으로 나뉨. 

### **메소드 영역 (Method Area)**
- 클래스 메타데이터(클래스 이름, 부모클래스 정보, 메소드 이름 및 필드 이름), 런타임 상수풀(컴파일 타임에 생성된 상수 값), 메소드와 관련된 데이터, 클래스 로더 정보를 저장.
- JVM 시작시 생성되어 종료시까지 유지.
- **Runtime Constant Pool**
    - 메서드 영역에 존재하는 별도의 관리영역
    - 각 클래스/인터페이스마다 별도의 Constant pool 테이블이 존재
    - 상수 자료형을 저장하고 참조하고 중복을 막는 역할을 함. → 실행속도 향상, 메모리 낭비 줄임.

#### 펌젠 영역 (PermGen, Permanent Generation)
- Java7까지 JVM의 메소드 영역을 저장하는 방식
- JVM 힙 영역에 존재 (클래스 메타데이터도 GC대상 → 고정 크기 제한으로 메모리 부족문제를 해결하기 위해)
- 크기가 고정되어 있으며, 필요시 동적확장이 어렵다.
    - OutOfMemoryError 발생 가능: `java.lang.OutOfMemoryError: PermGen space`(더이상 메모리를 할당할 수 없음)
        - 메모리 제한 : 많은 수의 클래스가 로드 될 때
        - 동적 클래스 로드(리플렉션, 프록시)를 과도하게 사용할 때

#### 메타 스페이스 영역 (Metaspace)
- Java8부터 JVM의 메소드 영역을 저장하는 방식
- 네이티브 메모리(운영체제가 관리하는 메모리 공간)에 위치 (클래스 메타데이터는 GC 대상이 아님.)
- 동적확장이 가능함 (PermGen의 OutOfMemoryError 문제를 완화.)
    - 설정된 `MaxMetaspaceSize`를 초과하면 여전히 OutOfMemoryError가 발생할 수 있음.

#### (+) 메타스페이스 영역에서는 OutOfMemoryError 가 언제, 어디서 발생하는가. 
- 메타스페이스의 최대 크기 값을 초과하게 될 때
    - 클래스가 과도하게 로드되는 경우(예: 동적 프록시 클래스 생성, 리플렉션 활용 등)
    - 설정된 메타스페이스 크기 제한을 초과할 때
- 네이티브 메모리의 가용 메모리가 부족할 때
    - 예: 다른 애플리케이션이 과도하게 메모리를 사용하거나, 서버에 네이티브 메모리가 부족한 경우.
<br>

----

### **힙 영역 (Heap Area)**
- 객체 인스턴스가 생성되는 공간 (new 연산자로 생성된 모든 객체는 힙 영역에 할당)
- 가비지 컬렉터의 주요 대상
- 발생할 수 있는 문제 : 가비지 컬렉션 오버헤드 (너무 자주 발생하거나 오래걸려서 성능저하), 사용하지 않는데 객체에 대한 참조가 남아있어 가비지 컬렉터가 회수하지 못하는 경우 → 메모리 사용량 증가

### **(+) 힙영역은 Young 영역과 Old 영역 으로 나눠 관리한다**
1. **Young 영역**
    1. eden : new를 통해 생성된 객체가 위치. GC이후 살아남은 객체는 survivor로 이동
    2. survivor 0, survivor 1 : 최소 1번의 GC에서 살아남은 객체가 존재 / 둘 중 하나는 꼭 비어있어야 하는 특별한 규칙이 있음.
    - 새로 생성된 객체들이 저장되는 영역으로, 여기서 자주 가비지 컬렉션이 발생.
    - **Minor GC**라고 하며, Young 영역에 있는 오래된 객체는 Old 영역으로 이동.
2. **Old 영역**:
    - Young 영역을 지나 일정 기간 동안 생존한 객체들이 이동하는 영역.
    - **Major GC** 또는 **Full GC**라고 부르며, 주로 큰 객체들을 정리
    - Major GC는 Minor GC에 비해 시간과 리소스가 많이 소모되므로 성능에 영향을 줄 수 있음.
    - 왜 Young영역보다 크게 할당되는가? → Young영역은 수명이 짧아서 큰 공간을 필요하지 않고, 큰객체는 바로 Old영역에 할당되기도 하기 때문에.

----

<br>

### **스택 영역 (Stack Area)**
- 메서드 호출 시 지역 변수, 매개변수, 반환 값 등이 저장되는 영역 (임시적으로 사용되는 변수, 정보들이 저장)
- 메서드가 호출될 때마다 새로운 스택 프레임이 생성되고, 메서드가 종료될 때 스택 프레임이 해제됨.
- 스택 오버플로우(스택 메모리가 부족한 경우)가 발생할 수 있음. 왜 발생? → 너무 많은 지역변수 사용, 재귀함수 너무 깊이 호출, 무한 루프

### PC 레지스터
- 현재 실행 중인 **명령어의 주소**를 저장하는 공간

### **네이티브 메소드 스택**
- 자바가 아닌 **네이티브 코드**(C/C++ 등으로 작성된 코드)를 실행할 때 사용되는 메모리 영역
- 자바 코드가 컴파일되어 생성되는 바이트 코드가 아닌 실제 수행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역
- JNI(Java Native Interface)를 통해 호출된 코드가 여기서 실행
    - 자바와 다른언어로 작성된 코드를 서로 연결하여 사용할 수 있도록 해주는 인터페이스