# 객체지향, 절차지향, SOLID원칙, 클래스, 인스턴스, 객체 등

<br>

## 객체지향 프로그래밍(Object-Oriented Programming, OOP)
- 현실세계의 개념을 '객체'로 추상화하여 객체를 중심으로 프로그램을 설계하는 방식.
- 장점 : 코드 재사용성과 유지보수성이 우수. 복잡한 대규모 시스템에 적합한 방식.
- 단점 : 설계가 복잡할 수 있음.
- *** 대표적인 객체 지향적 언어 : Java

### (+) 객체지향 프로그래밍을 현실세계에 빗대어 본다면?
- 핫스왑 키보드의 경우 스위치만 빼서 청축에서 갈축으로 갈축에서 백축으로 자유롭게 변경할 수 있음 '스위치'를 변경할 때 다른 부품들을 변경/수정하지 않아도 됨. 이러한 구조를 '객체지향적'이라고 할 수 있음.

<br>

----

<br>

### 객체 지향의 4가지 속성
1. 추상화(Abstraction)
   - 현실 세계의 복잡한 개체를 단순화 하는 과정
   - 이점 : 문제 해결에만 집중할 수 있도록 '시스템의 복잡도'를 줄여줌.
   - ex. 자동차를 객체로 표현한다고 했을 때 바퀴의 내부 구조까지 상세하게 표현하지 않고, 색깔, 속도, 움직임 등 핵심적인 특징만 추출하여 모델링함 → [인터페이스, 추상클래스]((https://github.com/ddururiiiiiii/TIL/blob/main/Java/241126%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%20%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4.md))가 이에 해당.

2. 캡슐화 (Encapsulation)
   - 객체의 내부 데이터를 외부에서 접근하지 못하도록 감싸는 것.
   - 이점 : 데이터의 무결성 보장, 코드의 유지보수성 높임.
   - ex. 접근제어자, Getter, Setter

3. 상속 (Inheritance)
   - 부모 클래스를 상속 받아 자식 클래스가 사용하는 것 (= 부모 메소드의 사용권을 허락 받는 것)
   - 이점 : 코드의 재사용성, 중복 줄이기, 편리성.

4. 다형성 (Polymorphism)
   - 같은 메서드, 객체가 다양한 방식으로 동작하는 방식
   - 이점 : 유연하고 확장 가능한 코드를 작성할 수 있도록 함.
   - ex. [오버로딩(Overloading), 오버라이딩(Overrading)]((https://github.com/ddururiiiiiii/TIL/blob/main/Java/241120%20Overloading%20VS%20Overriding.md))

<br>

----

<br>

### SOLID 원칙
1. **단일 책임의 원칙**
    - 하나의 클래스는 하나의 책임만 가짐
    - 현실세계 ex1. 요리사와 청소부 : 요리사는 요리만, 청소는 청소만 해야지 청소하는 사람이 요리하면 혼란이 생기고 효율이 떨어질 수 있음
    - 현실세계 ex2. 자동차에서 바퀴는 달리는 기능에 집중, 라디오는 소리를 내는 기능에 집중.
    - Java ex. 도메인, 비지니스 로직에 따라 패키지를 구분 (멤버클래스 : 멤버 정보만 관리 / 멤버 레파지토리 : 데이터 저장 담당.)

2. **개방-폐쇄의 원칙**
    - 확장에는 열려 있어야 하지만 수정에는 닫혀있어야 함. ( = 기능을 추가할 수 있지만 기존의 코드를 수정하지 않아야 함)
    - 현실세계 ex. 노트북, 스마트폰은 확장 슬롯이 있는데 다른 장치를 연결하거나 메모리 확장할 수 있는 기능을 추가할 수 있음. 이 슬롯은 새로운 기능을 추가할 수 있지만 그 때문에 제품을 뜯어내거나 회로를 변경하지 않아도 됨.
    - Java ex. [추상클래스, 인터페이스](https://github.com/ddururiiiiiii/TIL/blob/main/Java/241126%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%20%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4.md)

3. **리프코프 치환 원칙**
    - 자식 클래스는 부모 클래스의 기능을 온전히 수행할 수 있어야 함.
    - 현실세계 ex. 트럭은 자동차의 기본 기능 (운전)을 갖추면서도 짐을 실을 수 있는 기능을 가지고 있고 스포츠카도 역시 자동차의 기본 기능을 갖추면서도 속도를 빨리내는 본인만의 기능을 가지고 있음.
    - Java ex. [오버라이딩(Overriding)](https://github.com/ddururiiiiiii/TIL/blob/main/Java/241120%20Overloading%20VS%20Overriding.md)된 메소드는 부모 클래스의 메소드와 동일한 의미를 유지해야 함.

4. **인터페이스 분리 원칙**
    - 인터페이스는 필요에 따라 작게 분리해야 함
    - 현실세계 ex1. 식당에서 고객, 요리사, 웨이터는 각각의 역할이 있음.
    - 현실세계 ex2. 티비 리모콘은 티비만 작동, 에어컨 리모콘은 에어컨만 작동하는 형태.

5. **의존 역전 원칙**
    - 구체적인 구현보다 추상화에 의존해야 함.
    - 상위 모듈(비즈니스 로직)과 하위 모듈(구현 세부사항)이 직접적으로 연결되지 않고, 인터페이스나 추상 클래스를 통해 연결되도록 함.
    - 현실세계 ex. 상위 모듈인 교통카드 시스템은 개별 하위 모듈인 개별교통수단에 종속되지 않고 둘 모두 공통 결제 인터페이스에 의존하여 새로운 교통카드가 생겨도 기존 교통카드를 계속 사용할 수 있음.

<br>

----

<br>
<br>

## 절차지향 프로그래밍 (Procedural Programming)
- 순서적인 절차, 함수로 구성된 코드흐름을 중시하는 방식
- 장점 : 빠른 실행을 필요로 하는 간단한 프로그램에 적합
- 단점 : 큰 프로젝트에서 유지보수가 어려움.
- 대표적인 절차 지향적 언어 : C언어

### (+) 절차지향 프로그래밍을 현실세계에 빗대어 본다면?
- 요리의 경우 레시피 즉, 순서와 절차가 가장 중요함. 순서와 절차가 변경될 경우 아예 다른 결과를 나타낼 수도 있음. 이러한 구조가 '절차지향적'이라고 할 수 있음. 

### (+) 객체 지향의 반대는 절차 지향인가?
- 엄밀히 따지면 아님. 정반대의 개념은 아니고 서로 다른 사고방식과 설계 방식을 가진 것이라는 표현이 더 적합.
- 객체 지향적 프로그래밍에도 '순서'와 '절차'가 있음. 그러나 객체 지향 프로그래밍의 '절차'와 '순서'는 '객체'의 흐름에 관련된 것이고 '객체'에 더 초점이 맞춰져있음.
- 객체지향적 대표 프로그래밍 언어인 JAVA도 절차지향적으로 설계가 가능함.

### (+) 절차 지향이 왜 객체지향보다 성능이 좋은가?
- 절차 지향은 단순히 함수를 호출하는 작업을 수행하기 때문에 함수 호출에 들어가는 오버헤드가 적고 코드 실행경로가 단순함.
- 불필요한 객체를 생성하지 않고 함수 중심으로 처리하기 때문에 [가비지 컬랙션(GC)](https://github.com/ddururiiiiiii/TIL/blob/main/Java/241217%20GC.md)의 빈도나 필요성이 적어 객체 지향보다 빠른 성능을 가지고 있음.
- *** 오버헤드 : 추가 자원이 소모되는 현상

<br>

----

<br>

## 클래스 vs 객체 vs 인스턴스

| 구분       | 개념적 의미                       | 정의                                           | 비유                         | 예시 (Java)                   | 설명 |
|------------|-----------------------------------|------------------------------------------------|------------------------------|-------------------------------|------|
| 클래스     | 설계도                             | 객체를 만들기 위한 틀                          | 집을 짓기 위한 도면          | `class Dog { ... }`          | 실제 데이터를 담지 않음 |
| 객체       | 개념적 존재                        | 클래스로부터 생성된 모든 실체 (넓은 의미)     | 도면으로 지은 실제 집        | `Dog myDog = new Dog();` 중 `myDog` | 어떤 클래스의 인스턴스일 수도, 아닐 수도 있음 |
| 인스턴스   | 구체적 실체                        | 특정 클래스에서 생성된 객체 (좁은 의미)       | Dog 도면으로 만든 집         | `myDog`은 `Dog` 클래스의 인스턴스 | 어떤 클래스에서 생성되었는지가 명확함 |

---
