# AOP (Aspect-Oriented Programming)

- **관점 지향 프로그래밍**
- 프로그램의 핵심 비즈니스 로직에서 부가적인 관심사를 분리하는 프로그래밍 방식
- 객체 지향 프로그래밍을 보완하는 개념, OOP에서 해결하기 어려운 문제들을 보다 쉽게 해결할 수 있음.
- 스프링에서는 로깅, 트랜잭션 관리, 권한 체크 등을 따로 관리할 수 있게 해줌.
- 프록시 객체를 사용하며 프록시 패턴을 기반으로 작동함.
- 스프링 AOP는 **메서드 실행**에 초점을 맞추며, 클래스나 필드 수준의 AOP는 지원하지 않음.

## AOP가 왜 필요할까? (장단점)
- 애플리케이션을 개발하다 보면 여러 메서드나 클래스에서 **비슷한 기능**이 반복되는 경우가 많은데 AOP를 사용하면 **공통된 관심사(Cross-Cutting Concerns)**를 분리하여 핵심 기능에 집중할 수 있게 함.
- 장점
    - **코드 재사용성** : 공통된 기능을 한 곳에서 관리.
    - **유지보수 용이** : 코드 수정이 쉬워짐
    - **비즈니스 로직 분리**: 핵심 로직에만 집중 가능.
- **단점**
    - **학습 곡선** : 초반에는 AOP의 개념과 용어(Pointcut, Advice 등)를 이해하기 어려울 수 있음.
    - **디버깅 어려움** : 프록시 기반 동작으로 인해 디버깅 시 실제 호출 흐름을 파악하기 어려울 수 있음.
    - **오용 위험** : 너무 많은 부가 로직을 추가하면 코드가 복잡해지고 성능에 영향을 줄 수 있음.

## IoC 컨테이너와 AOP의 관계
- IoC 컨테이너는 AOP를 구현하는 데 필요한 **프록시 객체 생성**을 담당
- 스프링 IoC 컨테이너가 없으면 AOP를 런타임에서 적용할 수 없음.
- IoC는 객체 생성 및 의존성 관리를 분리하고 AOP는 공통 로직과 핵심 로직을 분리.

## 다양한 AOP 적용 방식

### 1. 컴파일 시점 적용

- 컴파일 시점에서  AOP적용이 이루어지는 방식 (**AspectJ 컴파일러**가 일반 `.java` 파일을 컴파일할 때 부가기능을 넣어서 `.class` 파일로 컴파일해주는 것을 의미)
- AspectJ와 같은 AOP 프레임워크를 사용하여야 함.
- 가장 강력하고 정교한 AOP구현을 제공하지만, AspectJ를 학습하기 위해선 엄청난 분량과 설정의 번거로움이 있어서 주로 런타임 시점 적용방식인 스프링 AOP를 사용 (스프링은 AspectJ의 문법을 차용해서 프록시 방식의 AOP를 적용. 직접 사용하는 것은 아님)

### 2. 클래스 로딩 시점 적용
- JVM내 클래스로더에 `.class` 파일을 올리는 시점에 **바이트 코드를 조작**해 부가기능 로직을 추가하는 방식
- 컴파일 이후에도 수정 없이 AOP를 적용할 수 있어 편리하지만 클래스 로더에 종속적일 수 있음.

### 3. 런타임 시점 적용
- 런타임에서 AOP적용이 이루어지는 방식 (컴파일도 다 끝나고, 클래스 로더에 클래스도 다 올라가서 이미 자바가 실행되고 난 다음)
- 스프링의 경우 런타임 시점의 AOP를 사용. = 이를 다이내믹 프록시라고 함.
- 프록시를 사용하기 때문에 AOP기능에 일부 제약이 있지만, 특별한 컴파일러나 클래스 로더를 설정하지 않아도 스프링이 알아서 자동으로 설정해주기 때문에 훨씬 편리하지만 프록시 생성 오버헤드가 발생할 수 있다는 단점이 있다.

## AOP의 주요 개념
- Aspect : 공통된 기능을 모아놓은 단위. (예: 트랜잭션 관리, 로깅 등.)
- Join Point : AOP가 적용될 수 있는 지점. (예: 메서드 호출, 객체 생성 등.)
- Advice : 실제로 실행될 공통 기능 코드. 언제 실행할지에 따라 종류가 나뉨
    - Before Advice: 메서드 실행 전에 실행.
    - After Advice: 메서드 실행 후에 실행.
    - Around Advice: 메서드 실행 전후에 실행.
    - After Returning Advice: 메서드가 성공적으로 실행된 후 실행.
    - After Throwing Advice: 메서드 실행 중 예외가 발생하면 실행.
- Pointcut : AOP를 적용할 구체적인 조건을 지정. (예: 특정 패키지의 모든 메서드, 특정 클래스의 특정 메서드.)
- Weaving : Aspect와 비즈니스 로직을 연결하는 과정. 스프링에서는 런타임에 이 과정을 수행.

## 프록시를 생성하는 두 가지 방법
### 다이내믹 프록시 (JDK Dynamic Proxy)

- **Java 표준 라이브러리** (`java.lang.reflect.Proxy`)를 사용하여 동적으로 프록시 객체를 생성
- 다이내믹 프록시는 **인터페이스**를 기반으로 프록시 객체를 생성 → **인터페이스**를 반드시 구현해야만 프록시를 만들 수 있음.
- 실행 시점에 프록시 클래스가 **인터페이스를 구현**한 객체를 생성 → 인터페이스에 선언된 메서드 호출을 가로채서 원하는 추가 작업(Advice)을 수행한 후 실제 객체의 메서드를 호출
- **장점**: JDK 기본 기능으로 가볍고 간단함.
- **단점**: **인터페이스가 필수**. 구체 클래스만 있는 경우 사용할 수 없음.

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 인터페이스 정의
interface Service {
    void doSomething();
}

// 실제 객체
class ServiceImpl implements Service {
    @Override
    public void doSomething() {
        System.out.println("ServiceImpl: 실제 로직 실행");
    }
}

// InvocationHandler 구현
class MyInvocationHandler implements InvocationHandler {
    private final Object target;

    public MyInvocationHandler(Object target) {
        this.target = target; // 실제 객체
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before: 메서드 실행 전");
        Object result = method.invoke(target, args); // 실제 메서드 호출
        System.out.println("After: 메서드 실행 후");
        return result;
    }
}

// 프록시 생성 및 사용
public class DynamicProxyExample {
    public static void main(String[] args) {
        Service target = new ServiceImpl();
        Service proxy = (Service) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                new Class[]{Service.class},
                new MyInvocationHandler(target)
        );

        proxy.doSomething();
    }
}

```

### CGLIB 프록시 (씨지라이브러리 프록시)

- 바이트코드를 조작해 프록시 객체를 생성
- 인터페이스가 없더라도 **구체 클래스**를 기반으로 프록시를 생성할 수 있음.
- CGLIB는 대상 클래스를 **상속**받아 프록시 객체를 생성 → 메서드를 오버라이딩하여 원하는 추가 작업(Advice)을 수행하고 원본 메서드를 호출
- **장점**: 인터페이스가 없어도 **구체 클래스**만으로 프록시를 생성할 수 있음 → 유연하게 프록시 적용가능
- **단점**:
    - 클래스 상속을 사용하기 때문에 **`final` 클래스나 메서드는 프록시 생성 불가**.
    - 성능이 JDK 다이내믹 프록시에 비해 조금 떨어질 수 있음.

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

// 실제 객체
class Service {
    public void doSomething() {
        System.out.println("Service: 실제 로직 실행");
    }
}

// MethodInterceptor 구현
class MyMethodInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("Before: 메서드 실행 전");
        Object result = proxy.invokeSuper(obj, args); // 부모 클래스의 메서드 호출
        System.out.println("After: 메서드 실행 후");
        return result;
    }
}

// 프록시 생성 및 사용
public class CglibProxyExample {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(Service.class); // 상속받을 클래스 지정
        enhancer.setCallback(new MyMethodInterceptor());

        Service proxy = (Service) enhancer.create();
        proxy.doSomething();
    }
}

```

## **다이내믹 프록시 vs CGLIB 프록시 비교**

| **구분** | **다이내믹 프록시 (JDK)** | **CGLIB 프록시** |
| --- | --- | --- |
| **대상** | 인터페이스 기반 | 구체 클래스 기반 |
| **기술** | `java.lang.reflect.Proxy` 사용 | 바이트코드 조작을 통한 클래스 상속 |
| **인터페이스 필요 여부** | 필요 | 불필요 |
| **`final` 제한** | 상관 없음 | `final` 클래스나 메서드 프록시 불가 |
| **성능** | 비교적 빠름 | 조금 느림 |
| **사용 시점** | 인터페이스가 존재하는 경우 | 구체 클래스만 존재하거나 인터페이스가 없는 경우 |

### 스프링에서는?

- **디폴트 프록시 선택**
    - **인터페이스가 존재**하면 **JDK 다이내믹 프록시**를 사용
    - **인터페이스가 없을 경우**에는 **CGLIB**를 사용
    - → 스프링은 기본적으로 다이내믹 프록시를 사용하며, 인터페이스가 없는 경우 CGLIB 프록시를 사용
    - 과거에는 CGLIB 프록시가 성능이 더 좋다고 알려져 있었지만, 현재는 두 방식의 성능 차이가 크지 않음.
    - **단순 메서드 호출**의 성능은 **CGLIB**가 더 빠름 → 초기 프록시 객체 생성은 JDK 다이내믹 프록시가 더 빠르고 가벼움.

⇒ 요즘은 다이내믹 프록시보다 **CGLIB를 많이 쓴다.**

- 이유 : 다이내믹 프록시는 리플렉션 API를 사용하기 때문에 **CGLIB보다 성능이 3배 정도 느리고, CGLIB는 인터페이스 없이도 사용가능해서.**
- 스프링 부트 2.0부터 **CGLIB가 디폴트. (왜 한참 지나서 됐을까. CGLIB가 오픈 소스여서 신뢰도와 검증이 늦었기 때문에)**