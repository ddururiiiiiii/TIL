## **1. 영속성 컨텍스트 (Persistence Context)**

- 엔터티(Entity)를 **관리**하는 JPA의 **논리적 작업 공간**
- JPA는 영속성 컨텍스트를 통해 엔터티와 데이터베이스를 동기화하고, 엔터티 상태를 관리

### **특징**

1. **엔터티 관리** : 영속 상태의 엔터티는 영속성 컨텍스트에 의해 관리됩니다.
2. **1차 캐시** : 영속성 컨텍스트 내부에 엔터티를 캐싱하여 동일한 엔터티를 중복 조회하지 않음.
3. **변경 감지(Dirty Checking)** : 영속 상태의 엔터티 변경 사항을 자동으로 감지하여 데이터베이스에 반영.
4. **쓰기 지연** : SQL 실행을 지연시키고, 트랜잭션 커밋 시 한 번에 SQL을 실행

---

## **2. 1차 캐시와 2차 캐시**

### **1차 캐시**

- **영속성 컨텍스트 내부의 캐시**로, 동일한 트랜잭션 내에서 엔터티를 메모리에 저장하여 중복 조회를 방지
    - → 애플리케이션 성능 최적화 및 데이터베이스 접근 횟수 줄임.
- 같은 트랜잭션에서 동일한 엔터티를 반복적으로 조회해도 데이터베이스에 접근하지 않고, 1차 캐시에서 반환
    - 엔터티는 **키 값(primary key)**으로 식별됩니다.

### **1차 캐시 동작 예시**

```java
EntityManager em = emf.createEntityManager();
em.getTransaction().begin();

// 데이터베이스에서 조회 (1차 캐시에 저장)
User user1 = em.find(User.class, 1L);

// 같은 트랜잭션 내에서 동일 엔터티를 조회 (1차 캐시에서 반환)
User user2 = em.find(User.class, 1L);

System.out.println(user1 == user2); // true (동일 객체)

em.getTransaction().commit();
em.close();

```

---

### **2차 캐시**

- **JPA 제공**이 아닌, Hibernate와 같은 구현체가 제공하는 **글로벌 캐시**
- **1차 캐시**는 **영속성 컨텍스트**(즉, 메모리 상의 관리 영역) 내에서 **현재 트랜잭션** 중에만 데이터를 캐시 → **2차 캐시**는 **여러 트랜잭션**에서 공통으로 사용할 수 있는 **글로벌 캐시임** 즉, 애플리케이션 내에서 **어떤 트랜잭션이든 캐시된 데이터를 공유**할 수 있음.
- 2차 캐시는 **외부 저장소(메모리, 파일, Redis 등)**에 저장됨.
- 성능이나 속도를 향상시킬수 있음.
- 다수의 트랜잭션이 동일한 데이터를 자주 조회하는 경우 DB를 매번 조회하는 것보다는 2차 캐시에서 가져오는 것이 훨씬 효율적

### **2차 캐시 설정 예시 (Hibernate)**

```xml
<hibernate-configuration>
    <session-factory>
        <!-- 2차 캐시 활성화 -->
        <property name="hibernate.cache.use_second_level_cache">true</property>
        <property name="hibernate.cache.region.factory_class">org.hibernate.cache.ehcache.EhCacheRegionFactory</property>
    </session-factory>
</hibernate-configuration>

```

### Redis?

- 고성능의 인메모리 데이터 저장소
- 캐시와 세션관리에 사용
- 메모리 기반 → 디스크가 아닌 RAM에 저장해서 빠르게 데이터를 읽고 쓸 수 있음.


### **2차 캐시를 잘 사용하지 않는 이유**

### (1) **복잡한 설정**

- 2차 캐시를 사용하려면, **추가적인 캐시 구현체(Ehcache, Hazelcast 등)**를 설정하고 JPA와 통합해야 하는데 설정이 복잡해지고 유지보수 비용이 증가할 수 있음.

### (2) **캐시 일관성 문제**

- 데이터베이스에서 데이터를 수정했을 때, 2차 캐시에 저장된 데이터와 **동기화가 제대로 이루어지지 않으면** 데이터가 일관되지 않을 위험이 있음. 특히, 데이터가 자주 변경되는 환경에서는 캐시 무효화 처리가 까다로워질 수 있습니다.

### (3) **분산 환경에서의 제약**

- 2차 캐시는 기본적으로 애플리케이션 내에서만 유효하므로, **여러 서버로 분산된 환경**에서는 캐시 동기화 문제가 발생할 수 있음. 이를 해결하려면 별도의 **분산 캐시 시스템**(예: Redis, Memcached)이 필요.

### (4) **DB와 캐시 관리의 복잡성**

- 2차 캐시를 사용하면 데이터베이스와 캐시 양쪽에서 데이터를 관리해야 하므로 복잡도가 높아짐

### (5) **이미 효율적인 1차 캐시**

- JPA의 **1차 캐시(영속성 컨텍스트)**는 트랜잭션 범위 내에서 캐시 역할을 충분히 함.
- 대부분의 애플리케이션은 1차 캐시만으로도 충분히 좋은 성능을 발휘하기 때문에 2차 캐시가 필요하지 않은 경우가 많음.

### **2차 캐시를 사용하는 방법**

### (1) **2차 캐시 설정의 기본 흐름**

1. **캐시 구현체 선택**: Ehcache, Hazelcast, Infinispan 등.
2. **JPA 캐시 설정**: 2차 캐시를 활성화하고 캐시 정책 설정.
3. **캐시 매핑**: 특정 엔티티나 쿼리 결과를 캐시에 저장하도록 설정.
   
   
---

### **1차 캐시와 2차 캐시의 차이점**

| **구분** | **1차 캐시** | **2차 캐시** |
| --- | --- | --- |
| **위치** | 영속성 컨텍스트 내부 | 애플리케이션 범위 (글로벌 캐시) |
| **범위** | 트랜잭션 단위 | 여러 트랜잭션에 걸쳐 공유 가능 |
| **저장소** | 메모리 | 메모리, 파일, 외부 캐시 (e.g., Redis) |
| **제공 여부** | JPA 표준 | JPA 구현체(Hibernate 등)에서 제공 |
| **목적** | 동일 트랜잭션 내 중복 조회 방지 | 데이터베이스 부하 감소 및 성능 최적화 |

---

### **4. 더티 체킹 (Dirty Checking) = 변경 감지**

- **JPA**에서 객체 상태 변경을 자동으로 감지하고, **트랜잭션 커밋 시 변경 사항을 DB에 반영**하는 기능
- 객체가 **영속성 컨텍스트에 저장**되면, 그 객체의 상태를 **변경했는지 여부를 추적**하고, 트랜잭션을 커밋할 때 **자동으로 DB에 반영**하는 것
- 더티 체킹 덕분에 개발자가 직접 SQL 쿼리를 작성하지 않고도 객체 상태 변경을 반영할 수 있음.
- **속성 컨텍스트(Persistence Context)** 내에서 객체의 상태를 추적하는 방식

### **동작 원리**

1. **초기 상태(snapshot) 저장**: 엔터티가 영속성 컨텍스트에 저장될 때, 엔터티의 초기 상태를 저장
2. **변경 감지**: 트랜잭션이 커밋되기 전, 엔터티의 현재 상태와 초기 상태를 비교
3. **SQL 생성**:변경된 필드에 대해서만 SQL `UPDATE` 쿼리를 생성하여 실행

### **더티 체킹 예시**

```java
em.getTransaction().begin();

User user = em.find(User.class, 1L); // 영속 상태
user.setName("Updated Name"); // 엔터티 변경

em.getTransaction().commit(); // 변경 감지가 일어나 DB에 UPDATE 쿼리 실행
```

### **SQL 실행 결과**

```sql
UPDATE users SET name = 'Updated Name' WHERE id = 1;
```

---

### **더티 체킹 장점**

- **명시적 `UPDATE` 호출이 필요 없음**. (수동으로 DB 업데이트 쿼리를 작성하지 않아도)
- 엔터티 변경만으로 데이터베이스를 자동으로 동기화.

### 나의 결론
JPA, ORM, 영속성 컨텍스트, 1차캐시, 2차캐시 모두 결국은 데이터 베이스의 접근 횟수를 줄이기 위한 방법 및 장치들 → 데이터베이스를 최대한 객체지향적으로 사용하기 위해 혹은 데이터베이스와 애플리케이션 간의 통신비용을 최소화하고 성능을 극대화 하기 위해서인 것 같음.