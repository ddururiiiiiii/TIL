# **옵티마이저 (Optimizer)**

- 데이터베이스에서 SQL 쿼리를 **가장 효율적으로 실행하기 위한 최적의 계획**(Execution Plan)을 자동으로 선택하는 역할을 하는 데이터베이스 엔진.

### **옵티마이저의 역할**

- 옵티마이저는 **SQL 쿼리를 실행하는 여러 가지 방법**을 평가하여 가장 적합한 실행 계획을 생성
- 옵티마이저는 데이터를 가져오기 위해 **인덱스를 사용할지, 테이블 전체를 스캔할지** 등을 결정
- 여러 테이블이 조인될 경우 어떤 테이블을 먼저 읽을지 어떤 방식(중첩 루프, 해시 조인 등)으로 조인을 수행할지 선택

### **옵티마이저의 동작 과정**

1. **SQL 파싱 :** SQL 쿼리를 읽고 문법과 구조를 분석.
2. **옵티마이저 단계**
    - 가능한 **여러 실행 경로**를 생성.
    - 실행 경로의 **비용(Cost)**을 계산.
    - 가장 효율적인 실행 경로를 선택.
3. **실행 계획 생성 :** 실행 계획은 실제로 데이터를 조회하거나 수정하기 위해 필요한 단계별 작업을 정의.

### **옵티마이저의 두 가지 유형**

### **1) 규칙 기반 옵티마이저(RBO, Rule-Based Optimizer)**

- 사전 정의된 규칙에 따라 실행 계획을 선택.
- 예: 인덱스가 있다면 항상 인덱스를 사용하는 식으로 단순한 규칙 적용.
- **단점**: 데이터 분포나 크기를 고려하지 않으므로 비효율적일 수 있음.

### **2) 비용 기반 옵티마이저(CBO, Cost-Based Optimizer)**

- 실행 경로별 비용(예: CPU 사용량, 디스크 I/O 등)을 계산해 최적의 계획을 선택.
- 데이터의 통계 정보(예: 테이블 크기, 인덱스 유무, 데이터 분포)를 기반으로 더 정교한 판단.
- **현대적인 데이터베이스는 대부분 CBO를 사용**.

### **옵티마이저가 고려하는 요소**

1. **테이블 크기 :** 테이블의 행(row) 수가 많을수록, 효율적인 검색 방식이 필요.
2. **인덱스 :** 특정 컬럼에 인덱스가 있다면, 이를 활용해 검색 속도를 높임.
3. **데이터 분포**
    - 예: 특정 조건에 해당하는 데이터가 전체의 1%라면 인덱스를 사용하는 것이 더 효율적.
4. **조인 방식 :** 여러 테이블 간 조인 시, 어떤 테이블을 먼저 읽을지와 조인 방식(중첩 루프, 해시 조인 등)을 결정.
5. **통계 정보 :** 테이블의 크기, 데이터 분포, 인덱스 상태 등.

### **옵티마이저의 현실 세계 비유**

### **옵티마이저는 "길 안내 GPS"와 비슷**

- **여러 경로를 비교**: 목적지로 가는 다양한 경로를 분석.
- **비용을 계산**: 최적의 경로를 선택(시간, 거리, 교통 상황 등을 기준으로).
- **결과를 실행**: 선택된 경로를 따라 이동.
- 옵티마이저는 데이터를 가져오기 위한 **여러 실행 경로를 분석**하고, 가장 빠르고 효율적인 방법을 선택

### **옵티마이저 관련 문제와 해결**

### 문제: 잘못된 실행 계획

- 옵티마이저가 최적의 경로를 선택하지 못하면 성능 저하 발생.

### 해결 방법

1. **통계 정보 갱신**: 옵티마이저가 최신 데이터를 기반으로 실행 계획을 생성하도록 데이터베이스 통계를 업데이트.
    
    ```sql
    ANALYZE TABLE Employees COMPUTE STATISTICS;
    ```
    
2. **힌트 사용** : SQL 쿼리에서 옵티마이저에게 특정 실행 방식을 강제.
    
    ```sql
    SELECT /*+ INDEX(Employees idx_age) */ * FROM Employees WHERE age > 30;
    ```
    
3. **쿼리 리팩토링** : 복잡한 쿼리를 간단하게 작성하거나 서브쿼리를 제거.

### **옵티마이저** 왜 중요한가?

- SQL 쿼리의 실행 속도는 옵티마이저가 결정하는 실행 계획에 따라 크게 달라질 수 있음.
- 잘 작성된 쿼리도 **옵티마이저가 비효율적인 실행 계획**을 선택하면 성능 문제가 발생할 수 있음.