### ** 힌트(Hint) (옵티마이저 힌트와 인덱스 힌트)**

### 힌트
- 데이터베이스 옵티마이저에게 실행계획을 조정하도록 지시하는 명령어

### 옵티마이저 힌트 
- 실행계획(조인방식 등) 최적화

### 인덱스 힌트
- 인덱스를 강제하거나 무시하거나

<br>

---

<br>

### **힌트(Hint)란?**

- *힌트(Hint)**는 데이터베이스 쿼리에 삽입하는 특수한 명령으로, **옵티마이저(Optimizer)**가 쿼리를 처리하는 방식을 **직접 제어**하는 도구
- 일반적으로 옵티마이저는 쿼리를 분석하고 최적의 실행 계획을 자동으로 생성하지만, 개발자가 **옵티마이저의 결정을 덮어쓰고 특정 방식으로 실행하도록 강제**할 때 힌트를 사용

### **1. 옵티마이저 힌트**

- 옵티마이저 힌트는 SQL 쿼리에 추가하여 옵티마이저가 쿼리를 처리하는 방식(테이블 액세스 방법, 조인 순서, 조인 알고리즘 등)을 강제할 수 있음.
- 보통 실무에서 사용하지 않는 것이 관례 → 인덱스 힌트를 사용함.

### **자주 사용되는 옵티마이저 힌트 예제 (Oracle)**
   - **FULL**: 테이블 전체 스캔(Full Table Scan) 강제.
```sql
SELECT /*+ FULL(employees) */ * FROM employees WHERE salary > 5000;
```
- **INDEX**: 특정 인덱스를 사용하도록 강제.

```sql
SELECT /*+ INDEX(employees idx_salary) */ * FROM employees WHERE salary > 5000;
```

- **USE_NL**: 중첩 루프 조인(Nested Loop Join) 강제.

```sql
SELECT /*+ USE_NL(e d) */ e.name, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

```

- **PARALLEL**: 병렬 처리 강제.

```sql
SELECT /*+ PARALLEL(employees, 4) */ * FROM employees;
```

### **옵티마이저 힌트의 장점**

1. **실행 계획 제어**: 자동 옵티마이저가 잘못된 실행 계획을 선택할 때 강제적으로 제어.
2. **성능 개선**: 데이터 분포나 특수 조건에 따라 최적의 실행 방식을 강제.

### **옵티마이저 힌트의 단점**

1. **이식성 부족**:
    - 데이터베이스마다 힌트 문법이 다름.
    - MySQL 힌트를 Oracle에서 사용할 수 없음.
2. **유지보수 어려움**: 데이터가 변경되면 힌트가 더 이상 최적이 아닐 수 있음.

### **2. 인덱스 힌트**

- 인덱스 힌트는 쿼리에서 **특정 인덱스를 강제로 사용**하도록 옵티마이저에게 지시하는 힌트
- 기본적으로 옵티마이저는 데이터 크기, 인덱스 선택도 등을 기준으로 실행 계획을 결정하지만, **인덱스를 강제 사용하거나 무시하도록 지시**할 수 있음.

### **인덱스 힌트 사용 예제 (MySQL, Oracle)**

- **특정 인덱스 강제 사용**

```sql
SELECT /*+ INDEX(employees idx_salary) */ * FROM employees WHERE salary > 5000;

```

- **해석**: `employees` 테이블의 `idx_salary` 인덱스를 강제로 사용.

- **인덱스 무시**

```sql
SELECT /*+ NO_INDEX(employees idx_salary) */ * FROM employees WHERE salary > 5000;
```

- **해석**: `employees` 테이블의 `idx_salary` 인덱스를 사용하지 않음.

-  **MySQL에서 FORCE INDEX 사용**

```sql
SELECT * FROM employees FORCE INDEX (idx_salary) WHERE salary > 5000;
```

- **해석**: `idx_salary` 인덱스를 강제 사용.
1. **MySQL에서 IGNORE INDEX 사용**

```sql
SELECT * FROM employees IGNORE INDEX (idx_salary) WHERE salary > 5000
```

- **해석**: `idx_salary` 인덱스를 무시.

### **인덱스 힌트의 장점**

1. **잘못된 인덱스 선택 방지**: 옵티마이저가 비효율적인 인덱스를 선택할 경우, 적절한 인덱스를 강제로 사용.
2. **인덱스 테스트 가능**: 새로운 인덱스가 성능을 개선하는지 테스트.

### **인덱스 힌트의 단점**

1. **동적 데이터에 취약**: 데이터 분포가 변경되면, 힌트가 성능을 저하시킬 수 있음.
2. **옵티마이저의 역할 제한**: 힌트를 남용하면 옵티마이저의 자동 최적화 기능을 방해.

---


### **힌트를 사용할 때의 주의사항**
1. **데이터 환경에 의존**: 데이터 크기, 분포가 변하면 힌트가 적합하지 않을 수 있음.
2. **남용 금지**: 힌트를 과도하게 사용하면 코드가 복잡해지고 유지보수가 어려워짐.
3. **옵티마이저 신뢰**: 대부분의 경우, 데이터베이스의 옵티마이저는 최적의 실행 계획을 선택함.

### 

| **특징** | **옵티마이저 힌트** | **인덱스 힌트** |
| --- | --- | --- |
| **목적** | 쿼리 실행 방식(조인, 병렬 처리 등)을 제어 | 특정 인덱스를 강제 사용하거나 무시 |
| **사용 사례** | 조인 순서 변경, 병렬 처리 강제 | 특정 인덱스를 테스트하거나 잘못된 인덱스 선택 방지 |
| **장점** | 실행 계획 제어, 성능 최적화 | 잘못된 인덱스 선택 방지, 성능 최적화 |
| **단점** | 유지보수 어려움, 데이터 변경에 취약 | 데이터 분포 변경 시 비효율 발생 |
| **주요 사용 예** | FULL 스캔 강제, 병렬 처리, 특정 조인 방식 지정 | 특정 인덱스 강제 사용, 인덱스 무시 |
