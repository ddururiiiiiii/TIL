# 인증, 인가, 권한 그리고 세션인증방식, 토큰인증방식 (JWT, OAuth 등)


## 인증(Authentication), 인가(Authorization), 권한(Permission)
| 구분       | 설명                                           | 예시 (개발 관점)                                       |
|------------|------------------------------------------------|--------------------------------------------------------|
| 인증 (Authentication) | **"누구인지 확인"** <br> 사용자가 누구인지 확인하는 절차        | 아이디/비밀번호 로그인, OAuth 로그인, JWT 발급 등       |
| 인가 (Authorization)  | **"무엇을 할 수 있는지 확인"** <br> 자원 접근 가능 여부 판단     | 관리자만 `/admin` 접근 가능, `@PreAuthorize` 사용 등    |
| 권한 (Role / Permission) | **인가의 판단 기준** <br> 역할/권한에 따라 인가 여부가 결정됨  | `ROLE_USER`, `ROLE_ADMIN`, `READ_ONLY`, `WRITE_ACCESS` 등 |

<br>

---

<br>

## 세션(Session) 인증 방식 VS JWT(Json Web Token) 인증 방식
| 항목             | 세션(Session) 인증 방식                              | JWT(Json Web Token) 인증 방식                          |
|------------------|------------------------------------------------------|--------------------------------------------------------|
| **인증 정보 저장 위치** | 서버 (세션 저장소, 메모리/DB/Redis 등)                   | 클라이언트 (JWT 토큰 자체에 정보 포함)                |
| **식별 수단**        | 세션 ID (ex. JSESSIONID 쿠키)                        | JWT 토큰 (Authorization 헤더에 포함)                   |
| **서버 확장성**     | 낮음 (세션 상태 공유 필요)                           | 높음 (토큰 기반이므로 무상태, Stateless 구조 가능)     |
| **보안**           | 서버 저장소 해킹 시 위험, 세션 탈취 우려              | 토큰 탈취 시 재사용 위험 (→ HTTPS, 짧은 유효기간 필요) |
| **유효기간 관리**    | 서버에서 세션 만료 시간 제어                          | 토큰 만료 시간(payload의 exp), 만료 전까진 유효        |
| **로그아웃 처리**   | 서버에서 세션 삭제로 즉시 처리 가능                  | 별도 블랙리스트 필요 (Redis 등으로 관리)               |
| **사용자 상태 추적** | 서버가 세션으로 사용자 상태 유지                      | 무상태 (Stateless), 요청마다 사용자 정보 포함됨         |
| **주로 사용되는 곳** | 전통적인 웹 애플리케이션 (ex. JSP, Spring MVC 등)     | SPA, 모바일 앱, MSA 구조 (ex. React+Spring Boot 등)    |
| **장점** | - 서버에서 세션 무효화 가능 → 로그아웃 즉시 반영<br>- 민감 정보 노출 위험 적음 (토큰 없이 세션 ID만 사용)<br>- 서버 측 통제 용이 | - 무상태(Stateless) 구조로 확장성 높음<br>- 클라이언트가 직접 인증 정보 보유 → 서버 부담 ↓<br>- API, 모바일, MSA 구조에 적합 |
| **단점** | - 서버에 세션 저장소 필요 → 메모리/DB/Redis 부하<br>- 서버 간 세션 공유 필요 (Scale-out 시 문제)<br>- CORS와 함께 쓰기 까다로움 (쿠키 기반) | - 토큰 탈취 시 유효시간까지 사용 가능 (무효화 어려움)<br>- 토큰이 클 수 있어 매 요청마다 네트워크 비용 ↑<br>- 로그아웃 처리 및 재발급(Refresh) 로직 필요 |


### 간단 비교 요약
- 세션 방식: 서버가 사용자 상태를 기억함 → 상태 유지 필요할 때 적합
- JWT 방식: 서버가 사용자 상태를 기억하지 않음(Stateless) → 확장성과 API 기반 시스템에 적합

### 토큰(Token)
- 
- 서버와 클라이언트가 통신할 때, 사용자의 인증 상태나 권한을 식별하기 위해 사용하는 고유한 문자열
보통 로그인 후 발급되고, 이후 요청에서 사용자 대신 인증 정보를 전달함.


<br>

---

<br>


## OAuth (Open Authorization)
- 사용자가 비밀번호를 직접 제공하지 않고, 제3자 서비스(구글, 네이버 등)의 인증을 위임받는 방식
- ex. 네이버 아이디로 로그인, 구글 아이디로 로그인 등

| 장점                                      | 단점                                     |
|-------------------------------------------|------------------------------------------|
| 사용자가 빠르게 로그인 가능 (SNS 계정)     | 외부 서비스 장애 시 로그인 불가          |
| 보안 부담이 줄어듦 (PW 저장 X)             | 소셜마다 응답 구조, 권한 방식 다름        |
| 간편한 회원가입 유도                       | 개인정보 항목은 제한적 (email 제공 제한 등) |


### OAuth 동작 흐름
~~~css
[1] 사용자 → 로그인 버튼 클릭 (구글 로그인 등)
 ↓
[2] 구글 로그인 창으로 이동
 ↓
[3] 사용자 로그인 → 권한 동의
 ↓
[4] 인가 코드(code) 전달 받음
 ↓
[5] 서버가 구글에 code를 전달 → access_token 획득
 ↓
[6] access_token으로 사용자 정보 요청
 ↓
[7] 우리 서비스 회원 가입 or 로그인 처리

~~~



## 다중 서버에서 세션기반 인증을 사용할 경우 발생할 수 있는 문제점
- 세션 불일치 문제 (= 세션 손실 문제) : 세션 정보가 특정 서버에만 저장되기 때문에, 다른 서버로 요청이 가면 로그인 정보가 없다고 나옴

### 🔧 해결 방법 (3가지 대표 방법)
1. 세션 스티키(sticky) 방식
- 항상 같은 사용자는 같은 서버로만 보냄 (IP 기반, 세션 쿠키 기반 등)
📌 장점: 간단함
💣 단점: 특정 서버에만 트래픽 쏠림 → 부하 불균형

2. 세션 클러스터링 (세션 공유)
- 세션 정보를 모든 서버가 공유할 수 있는 저장소에 저장
- 보통 Redis, Memcached, DB 등에 저장
- 📌 장점: 어떤 서버로 가도 세션 확인 가능
- 💣 단점: 저장소 장애나 네트워크 병목 가능
✨ 요즘엔 이 방식 많이 씀 (Redis 세션 저장)

3. JWT 기반 무상태 인증 (Stateless)
- 아예 세션 저장을 안 함!
- 로그인하면 JWT 토큰을 발급하고, 클라이언트가 이걸 요청마다 같이 보냄
- 서버는 토큰만 검증하면 끝 → 세션 저장 X
- 📌 장점: 서버 확장 쉬움, 로드밸런싱 문제 없음
- 💣 단점: 토큰 자체에 정보가 들어있으니 탈취 위험 있음 (→ https, 만료시간, Refresh Token 등 필요)