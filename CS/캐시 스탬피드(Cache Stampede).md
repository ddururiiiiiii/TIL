# 캐시 스탬피드(Cache Stampede)
- 많은 요청이 동시에 캐시를 갱신하려고 몰리는 현상
- 즉, 어떤 데이터가 캐시에 저장되어 있고 그 캐시의 유효기간이 끝난 상태인데, 동시에 여러 요청이 캐시에 접근했는데 이미 유효기간이 끝나 찾을 수 없어 다 같이 원본데이터를 조회하러 서버로 가다보니 트래픽이 폭주 되고 서버 부하를 유발하는 현상.

## 해결방법
### 1. 잠금 방식 (Mutex Lock / Cache-Aside Lock)
- 핵심: "누가 먼저 계산할지 정하자"
- 캐시에 값이 없을 때, 한 명만 DB를 조회하고 캐시에 저장하도록 락을 건다.
- 다른 요청은 그 값이 들어올 때까지 기다리거나 예전 값 사용.
- Redis의 SETNX나 Redisson 사용해서 락 구현 가능
- 단점: 락이 너무 오래 걸리면 응답 지연

### 2. 외부 재계산 방식 (External Recalculation / Refresh Ahead)
- 핵심: "백그라운드에서 미리 계산해둘게"
- 캐시 만료 전에 백그라운드 작업으로 데이터를 미리 다시 캐싱해서 사용자 입장에선 항상 최신 데이터가 있는 것처럼 보임.
- Spring에서 @Scheduled + Redis 조합으로 사용
- 단점: 자주 안 쓰는 키까지 무조건 미리 계산할 수 있음 (비효율)

### 3. 확률적 조기 재계산 (Probabilistic Early Recalculation)
-  핵심: "운 좋으면 미리 갱신한다"
- 캐시 만료 시간이 다가올 때, 확률적으로 DB 재조회 & 갱신 시도.
- 예) TTL이 10초인데 7초 지나면 30% 확률로 갱신, 9초 지나면 80% 확률로 갱신
- Reddit, Wikipedia 등이 사용하는 방식
- 구현이 좀 까다롭고 확률 설계 잘 해야 함

### 해결방법 (요약)
| 방식         | 특징           | 장점             | 단점           |
| ---------- | ------------ | -------------- | ------------ |
| 🔒 잠금      | 한 명만 계산      | 간단하고 명확        | 락 지연, 동시성 조심 |
| 🔁 외부 재계산  | 백그라운드로 갱신    | 사용자 입장에서 항상 신선 | 불필요한 계산 가능   |
| 🎲 확률적 재계산 | 갱신 타이밍을 랜덤하게 | 서버 부하 분산 가능    | 확률 설계 잘해야 함  |


- 실무에선 잠금 + TTL 랜덤화 조합이 가장 보편적이고, 트래픽 큰 곳에서는 확률 기반 or 외부 재계산도 적극 사용함.