# 메모리 관리 시스템

### 1. **가상 메모리(Virtual Memory)**

- 리눅스에서는 **가상 메모리**라는 개념을 사용하는데 여기서 가상메모리란 프로그램이 물리 메모리(RAM)에 직접 접근하지 않고, **가상의 주소 공간**을 사용하도록 하는 기술.
- 각 프로세스는 자신만의 **가상 주소 공간**을 가지고 있어서, 다른 프로세스와의 메모리 충돌을 방지함.
- 장점:
    - 메모리 보호: 하나의 프로그램이 다른 프로그램의 메모리에 접근하지 못함.
    - 메모리 효율성: 실제로 필요한 부분만 메모리에 적재(**페이징**).

### 2. **페이징(Paging)**

- 메모리를 작은 **페이지 단위(보통 4KB)**로 나누는 것.
- 프로세스가 사용하는 메모리 페이지는 물리 메모리에 올려지거나, 필요에 따라 디스크의 **스왑 공간**으로 옮겨질 수 있음.
    - **스왑 공간**: RAM이 부족할 때, 임시로 디스크를 사용하는 공간.

### 3. **메모리 영역**

프로세스는 다음과 같은 주요 메모리 영역을 사용함:

- **코드 영역(Text Segment)**: 프로그램의 실행 코드가 저장.
- **데이터 영역(Data Segment)**:
    - **정적 데이터**: 전역 변수, 초기화된 변수.
    - **BSS(BSS Segment)**: 초기화되지 않은 전역 변수.
- **힙(Heap)**: 동적으로 할당되는 메모리 공간.
- **스택(Stack)**: 함수 호출 시 사용되는 메모리(지역 변수, 함수 호출 기록 등).

### 4. **캐시(Cache)와 버퍼(Buffer)**

- **캐시**: 자주 사용하는 데이터를 저장해 빠르게 접근하도록 함(CPU 캐시, 디스크 캐시 등).
- **버퍼**: 데이터를 디스크에 쓰거나 네트워크로 전송하기 전에 임시 저장하는 공간.
- 리눅스는 가능한 한 메모리를 캐시와 버퍼로 활용해 성능을 높임.

### 5. **메모리 관리 기법**

- **Demand Paging(요구 페이징)**:
    - 프로그램이 필요할 때만 메모리에 페이지를 로드.
- **Copy-On-Write(COW)**:
    - 프로세스가 메모리를 복사하지 않고 공유하다가, 쓰기가 발생하면 복사(효율적인 메모리 사용).
- **Swapping(스와핑)**:
    - RAM이 부족하면 덜 자주 사용되는 페이지를 디스크로 이동.

### 6. **메모리 관리 단위**

- **페이지 테이블(Page Table)**:
    - 가상 주소와 물리 주소를 매핑하는 데이터 구조.
- **MMU(Memory Management Unit)**:
    - CPU가 가상 주소를 물리 주소로 변환하는 하드웨어.

### 7. **OOM Killer(Out of Memory Killer)**

- 시스템에 메모리가 부족할 때, 리눅스는 특정 프로세스를 종료시켜 메모리를 확보.
- 주로 메모리를 많이 사용하는 프로세스가 종료 대상이 됨.

### 예시

1. 큰 프로그램을 실행하면, 리눅스는 해당 프로그램의 코드와 데이터를 작은 페이지 단위로 나누어 RAM에 올림.
2. 필요하지 않은 데이터는 디스크의 스왑 공간으로 옮기고, 자주 사용되는 데이터를 캐시에 저장해 실행 속도를 높임.
3. 프로세스 간에 충돌이 없도록 각각 독립적인 가상 주소 공간을 제공